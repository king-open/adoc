[
  {
    "title": "\n      \n        \n\t\n\t\n\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\n\n      \n    ",
    "content": "\n  \n    \n      \n        API 设计指南\n      \n    \n  \n\n  \n\narticle pre {\n    overflow: visible;\n}\n\n\n\n\n\n  为了便于作为快速参考使用，许多指南的详细信息\n可以单独展开。打印此页面时，详细信息永远不会被隐藏。\n\n\n\n目录 \n             \n          \n\n\n  简介\n  基础原则\n  命名    \n      促进�����使用\n      努力实现流畅的使用\n      术语使用得当\n    \n  \n  约定    \n      一般约定\n      参数\n      参数标签\n    \n  \n  特殊说明\n\n\n简介 \n             \n          \n\n在编写 Swift 代码时提供清晰、一致的开发者体验很大程度上取决于 API 中出现的名称和习语。\n这些设计指南解释了如何确保你的代码感觉像是更大的 Swift 生态系统的一部分。\n\n基础原则 \n             \n          \n\n\n  \n    使用点的清晰性是你最重要的目标。\n诸如方法和属性之类的实体只声明一次但\n会被多次使用。设计 API 时要使这些用法清晰简洁。\n在评估设计时，仅仅阅读声明通常是不够的；\n始终检查用例以确保它在上下文中看起来清晰。\n  \n  \n    清晰比简短更重要。虽然 Swift\n代码可以紧凑，但使代码用最少的字符达到最小可能的长度并不是目标。\nSwift 代码中的简短性（如果出现）是强大类型系统和\n自然减少样板代码的特性的副作用。\n  \n  \n    为每个声明写文档注释。\n编写文档时获得的见解可能对你的设计产生深远的影响，\n所以不要推迟这项工作。\n\n    \n      如果你在用简单的术语描述你的 API 的功能时遇到困难，\n你可能设计了错误的 API。\n    \n\n\n    \n\n      \n        \n          使用 Swift 的 Markdown 方言。\n        \n        \n          以描述所声明实体的摘要开始。\n通常，一个 API 可以从其声明和摘要中完全理解。\n\n          /// **返回包含相同元素但顺序相反的 `self` 的\"视图\"。**\nfunc reversed() -> ReverseCollection<Self>\n          \n\n\n          \n\n            \n              \n                专注于摘要；这是最重要的部分。许多\n优秀的文档注释仅由一个出色的摘要组成。\n              \n              \n                如果可能，使用单个句子片段，以句点结尾。\n不要使用完整的句子。\n              \n              \n                描述函数或方法做什么以及它返回什么，\n省略空效果和 Void 返回：\n\n                /// **在 `self` 的开头插入** `newHead`。\nmutating func prepend(_ newHead: Int)\n\n/// **返回**包含 `head` 后跟 `self` 元素的 `List`。\nfunc prepending(_ head: Element) -> List\n\n/// 如果非空，则**移除并返回** `self` 的第一个元素；\n/// 否则返回 `nil`。\nmutating func popFirst() -> Element?\n                \n\n                注意：在像 popFirst 这样的罕见情况，摘要由\n多个用分号分隔的句子片段组成。\n              \n              \n                描述下标访问什么：\n\n                /// **访问**第 `index` 个元素。\nsubscript(index: Int) -> Element { get set }\n                \n              \n              \n                描述初始化器创建什么：\n\n                /// **创建**包含 `n` 个 `x` 重复的实例。\ninit(count n: Int, repeatedElement x: Element)\n                \n              \n              \n                对于所有其他声明，描述声明的实体是什么。\n\n                /// **一个集合，支持**在任何位置进行同样高效的插入/删除。\nstruct List {\n\n  /// `self` 开头的元素，如果 self 为空则为 `nil`。\n  var first: Element?\n  ...\n                \n              \n            \n\n          \n        \n        \n          可选地，继续添加一个或多个段落和项目符号。\n段落之间用空行分隔，使用完整的句子。\n\n          /// 将 `items` 中每个元素的文本表示    <span class=\"graphic\">←</span><span class=\"commentary\">摘要</span>\n/// 写入标准输出。\n///                                              <span class=\"graphic\">←</span><span class=\"commentary\">空行</span>\n/// 每个项目 `x` 的文本表示 <span class=\"graphic\">←</span><span class=\"commentary\">附加讨论</span>\n/// 由表达式 `String(x)` 生成。\n///\n/// - **Parameter separator**: 在项目之间    <span class=\"graphic\">⎫</span>\n///   打印的文本。                             <span class=\"graphic\">⎟</span>\n/// - **Parameter terminator**: 在末尾   <span class=\"graphic\">⎬</span><span class=\"commentary\"><a href=\"https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/SymbolDocumentation.html#//apple_ref/doc/uid/TP40016497-CH51-SW14\">参数部分</a></span>\n///   打印的文本。                                <span class=\"graphic\">⎟</span>\n///                                              <span class=\"graphic\">⎭</span>\n/// - **Note**: 要在不添加尾随          <span class=\"graphic\">⎫</span>\n///   换行符的情况下打印，传递 `terminator: \"\"`             <span class=\"graphic\">⎟</span>\n///                                              <span class=\"graphic\">⎬</span><span class=\"commentary\"><a href=\"https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/SymbolDocumentation.html#//apple_ref/doc/uid/TP40016497-CH51-SW13\">符号命令</a></span>\n/// - **SeeAlso**: `CustomDebugStringConvertible`,   <span class=\"graphic\">⎟</span>\n///   `CustomStringConvertible`, `debugPrint`.   <span class=\"graphic\">⎭</span>\npublic func print<Target: OutputStreamType>(\n  _ items: Any..., separator: String = \" \", terminator: String = \"\\n\")\n          \n\n\n          \n\n            \n              \n                使用已认可的\n符号文档标记\n元素在适当时添加超出摘要的信息。\n              \n              \n                了解并使用带有\n符号命令语法的已认可项目符号。 像 Xcode 这样的流行开发\n工具对以下关键字开头的项目符号给予特殊处理：\n\n                \n                  \n                    \n                      Attention\n                      Author\n                      Authors\n                      Bug\n                    \n                    \n                      Complexity\n                      Copyright\n                      Date\n                      Experiment\n                    \n                    \n                      Important\n                      Invariant\n                      Note\n                      Parameter\n                    \n                    \n                      Parameters\n                      Postcondition\n                      Precondition\n                      Remark\n                    \n                    \n                      Requires\n                      Returns\n                      SeeAlso\n                      Since\n                    \n                    \n                      Throws\n                      ToDo\n                      Version\n                      Warning\n                    \n                  \n                \n              \n            \n\n          \n        \n      \n\n    \n  \n\n\n命名 \n             \n          \n\n促进�����使用 \n             \n          \n\n\n  \n    包所要的词以避免使用点处的歧义，让阅读代码的人\n能够理解名称的含义。\n\n\n    \n      例如，考虑一个在集合中移除给定位置元素的方。\n\n      extension List {\n  public mutating func remove(at position: Index) -> Element\n}\nemployees.remove(at: x)\n      \n\n      如果我们从方法签名中省略 at 这个词，可能会让读者\n误以为该方法会搜索并移除一个等于 x 的元素，而不是使用 x 来\n指示要移除的元素的位置。\n\n      employees.remove(x) // 不清楚：我们是在移除 x 吗？\n      \n\n    \n  \n  \n    省略不必要的词。名称中的每个词都应该在使用点传达\n重要信息。\n\n\n    \n      可能需要更多的词来澄清意图或消除歧义，但那些\n重复读者已经拥有的信息的词应该被省略。特别是，省略那些\n仅仅重复类型信息的词。\n\n      public mutating func removeElement(_ member: Element) -> Element?\n\nallViews.removeElement(cancelButton)\n      \n\n      在这种情况下，Element 这个词在调用点没有添加任何重要信息。\n这个 API 会更好：\n\n      public mutating func remove(_ member: Element) -> Element?\n\nallViews.remove(cancelButton) // 更清晰\n      \n\n      偶尔，重复类型信息是必要的，以避免歧义，但通常\n最好使用描述参数角色而不是其类型的词。参见下一项\n了解详情。\n    \n  \n  \n    根据它们的角色而不是类型约束来命名变量、参数和关联类型。\n\n\n    \n      var **string** = \"Hello\"\nprotocol ViewController {\n  associatedtype **View**Type : View\n}\nclass ProductionLine {\n  func restock(from **widgetFactory**: WidgetFactory)\n}\n      \n\n      以这种方式重用类型名称未能优化清晰性和\n表达性。相反，努力选择一个表达实体角色的名称。\n\n      var **greeting** = \"Hello\"\nprotocol ViewController {\n  associatedtype **ContentView** : View\n}\nclass ProductionLine {\n  func restock(from **supplier**: WidgetFactory)\n}\n      \n\n      如果一个关联类型与其协议约束如此紧密绑定，以至于\n协议名称就是角色，通过在协议名称后附加\nProtocol 来避免冲突：\n\n      protocol Sequence {\n  associatedtype Iterator : Iterator**Protocol**\n}\nprotocol Iterator**Protocol** { ... }\n      \n    \n  \n  \n    补偿弱类型信息以澄清参数的角色。\n\n\n    \n      特别是当参数类型是 NSObject、Any、AnyObject\n或基本类型如 Int 或 String 时，类型信息和\n使用点的上下文可能无法完全传达意图。在这个\n例子中，声明可能是清晰的，但使用点是模糊的。\n\n      func add(_ observer: NSObject, for keyPath: String)\n\ngrid.add(self, for: graphics) // 模糊\n      \n\n      要恢复清晰性，在每个弱类型的参数前加上一个描述其\n角色的名词：\n\n      func add**Observer**(_ observer: NSObject, for**KeyPath** path: String)\ngrid.addObserver(self, forKeyPath: graphics) // 清晰\n      \n    \n  \n\n\n努力实现流畅的使用 \n             \n          \n\n\n  \n    优先选择使用点形成语法通顺的英语短语的方法和函数名称。\n\n\n    \n      x.insert(y, at: z)          <span class=\"commentary\">\"x，在 z 处插入 y\"</span>\nx.subviews(havingColor: y)  <span class=\"commentary\">\"x 的具有颜色 y 的子视图\"</span>\nx.capitalizingNouns()       <span class=\"commentary\">\"x，将名词大写\"</span>\n      \n\n      x.insert(y, position: z)\nx.subviews(color: y)\nx.nounCapitalize()\n      \n\n      当这些参数不是调用含义的���心时，在第一个或第二个参数之后，\n流畅性可以适当降低：\n\n      AudioUnit.instantiate(\n  with: description,\n  **options: [.inProcess], completionHandler: stopProgressBar**)\n      \n    \n  \n  \n    工厂方法的名称应以 “make” 开头，\n例如 x.makeIterator()。\n  \n  \n    初始化器和工厂方法调用的第一个参数\n不应该与基本名称形成以基本名称开头的短语，\n例如 x.makeWidget(cogCount: 47)\n\n\n    \n      例如，这些调用中的第一个参数不作为基本名称所在短语的一部分来阅读：\n\n      let foreground = **Color**(red: 32, green: 64, blue: 128)\nlet newPart = **factory.makeWidget**(gears: 42, spindles: 14)\nlet ref = **Link**(target: destination)\n      \n\n      在下面的例子中，API 作者试图在第一个参数中创造语法连续性。\n\n      let foreground = **Color(havingRGBValuesRed: 32, green: 64, andBlue: 128)**\nlet newPart = **factory.makeWidget(havingGearCount: 42, andSpindleCount: 14)**\nlet ref = **Link(to: destination)**\n      \n\n      在实践中，这条准则与参数标签的准则一起意味着\n除非调用执行值保留类型转换，否则第一个参数将有标签。\n\n      let rgbForeground = RGBColor(cmykForeground)\n      \n    \n  \n  \n    根据它们的副作用来命名函数和方法\n\n    \n      \n        没有副作用的应该读作名词短语，\n例如 x.distance(to: y)、i.successor()。\n      \n      \n        有副作用的应该读作祈使动词短语，\n例如 print(x)、x.sort()、x.append(y)。\n      \n      \n        命名可变/不可变方法对要保持一致。\n可变方法通常会有一个不可变的变体，具有相似的语义，\n但返回新值而不是就地更新实例。\n\n        \n          \n            当操作自然地用动词描述时，使用动词的祈使语气\n来命名可变方法，并应用”ed”或”ing”后缀来命名其不可变对应方法。\n\n            \n              \n                \n                  可变\n                  不可变\n                \n              \n              \n                \n                  x.sort()\n                  z = x.sorted()\n                \n                \n                  x.append(y)\n                  z = x.appending(y)\n                \n              \n            \n\n\n            \n\n              \n                \n                  优先使用动词的过去分词\n（通常添加”ed”）来命名不可变变体：\n\n                  /// 原地反转 `self`。\nmutating func reverse()\n\n/// 返回 `self` 的反转副本。\nfunc revers**ed**() -> Self\n...\nx.reverse()\nlet y = x.reversed()\n                  \n                \n                \n                  当添加”ed”在语法上不合适时（因为动词有直接宾语），\n使用动词的现在分词，\n通过添加”ing”来命名不可变变体。\n\n                  /// 从 `self` 中删除所有换行符\nmutating func stripNewlines()\n\n/// 返回删除了所有换行符的 `self` 的副本。\nfunc strip**ping**Newlines() -> String\n...\ns.stripNewlines()\nlet oneLine = t.strippingNewlines()\n                  \n                \n              \n\n            \n          \n          \n            当操作自然地用名词描述时，使用名词来命名不可变方法，\n并应用”form”前缀来命名其可变对应方法。\n\n            \n              \n                \n                  不可变\n                  可变\n                \n              \n              \n                \n                  x = y.union(z)\n                  y.formUnion(z)\n                \n                \n                  j = c.successor(i)\n                  c.formSuccessor(&i)\n                \n              \n            \n          \n        \n      \n    \n  \n  \n    布尔方法和属性的使用应该在非可变时读作关于接收者的断言，例如 x.isEmpty、\nline1.intersects(line2)。\n  \n  \n    描述某物是什么的协议应该读作名词（例如 Collection）。\n  \n  \n    描述能力的协议应该使用后缀 able、ible 或 ing\n（例如 Equatable、ProgressReporting）。\n  \n  \n    其他类型、属性、���量和常量的名称应该读作名词。\n  \n\n\n术语使用得当 \n             \n          \n\n\n  专业术语\n  名词 - 在特定领域或专业中具有精确、专门含义的词或短语。\n\n\n\n  \n    避免晦涩的术语，如果一个更常见的词能同样好地传达含义。\n如果”skin”能满足你的目的，就不要说”epidermis”。\n专业术语是一个重要的交流工具，但只应该在捕获否则会丢失的关键含义时使用。\n  \n  \n    如果你确实使用专业术语，要坚持其既定含义。\n\n\n    \n      使用技术术语而不是更常见词语的唯一理由是它能精确地\n表达否则会模糊或不清楚的内容。因此，API 应该\n严格按照其公认的含义使用该术语。\n\n      \n        \n          不要让专家感到惊讶：任何已经熟悉该术语的人\n如果我们似乎为它发明了新的含义，都会感到惊讶和愤怒。\n        \n        \n          不要让初学者感到困惑：任何试图学习该术语的人\n很可能会在网上搜索并找到其传统含义。\n        \n      \n    \n  \n  \n    避免缩写。缩写，尤其是非标准的缩写，\n实际上是专业术语，因为理解取决于\n正确将它们转换为非缩写形式。\n\n    \n      使用的任何缩写的预期含义应该\n通过网络搜索容易找到。\n    \n  \n  \n    拥抱先例。不要以牺牲与现有文化的一致性为代价\n来为完全的初学者优化术语。\n\n\n    \n      使用 Array 来命名一个连续的数据结构比使用\n像 List 这样的简化术语更好，即使初学者\n可能更容易理解 List 的含义。数组在现代计算中\n是基础的，所以每个程序员都知道——或者\n很快就会学到——什么是数组。使用大多数程序员\n熟悉的术语，他们的网络搜索和问题就会得到回报。\n\n      在特定的编程领域内，比如数学，\n一个广泛有先例的术语如 sin(x) 比解释性短语\n如 verticalPositionOnUnitCircleAtOriginOfEndOfRadiusWithAngle(x)\n更可取。注意在这种情况下，先例优先于避免缩写的指导原则：\n虽然完整的词是 sine，但”sin(x)”在程序员中已经\n使用了几十年，在数学家中使用了几个世纪。\n    \n  \n\n\n约定 \n             \n          \n\n一般约定 \n             \n          \n\n\n  \n    记录任何不是 O(1) 的计算属性的复杂度。人们经常假设属性访问不涉及\n重要的计算，因为他们以存储属性作为\n心智模型。当这个假设可能被违反时，请务必提醒他们。\n  \n  \n    优先使用方法和属性而不是自由函数。自由函数\n仅在特殊情况下使用：\n\n\n    \n\n      \n        \n          当没有明显的 self：\n\n          min(x, y, z)\n          \n        \n        \n          当函数是无约束的泛型：\n\n          print(x)\n          \n        \n        \n          当函数语法是既定领域表示法的一部分：\n\n          sin(x)\n          \n        \n      \n\n    \n  \n  \n    遵循大小写约定。类型和协议的名称是\nUpperCamelCase。其他所有内容都是 lowerCamelCase。\n\n\n    \n\n      在美式英语中通常全部大写出现的首字母缩写词和缩略语\n应该根据大小写约定统一使用大写或小写：\n\n      var **utf8**Bytes: [**UTF8**.CodeUnit]\nvar isRepresentableAs**ASCII** = true\nvar user**SMTP**Server: Secure**SMTP**Server\n      \n\n      其他缩写词应该被视为普通单词：\n\n      var **radar**Detector: **Radar**Scanner\nvar enjoys**Scuba**Diving = true\n      \n    \n  \n  \n    方法可以共享基本名称，当它们共享相同的基本\n含义或当它们在不同的领域中操作时。\n\n\n    \n      例如，以下做法是鼓励的，因为这些方法本质上做\n相同的事情：\n\n      extension Shape {\n  /// 如果 `other` 在 `self` 的区域内，则返回 `true`；\n  /// 否则返回 `false`。\n  func **contains**(_ other: **Point**) -> Bool { ... }\n\n  /// 如果 `other` 完全在 `self` 的区域内，则返回 `true`；\n  /// 否则返回 `false`。\n  func **contains**(_ other: **Shape**) -> Bool { ... }\n\n  /// 如果 `other` 在 `self` 的区域内，则返回 `true`；\n  /// 否则返回 `false`。\n  func **contains**(_ other: **LineSegment**) -> Bool { ... }\n}\n      \n\n      而且由于几何类型和集合是不同的领域，\n在同一个程序中这样做也是可以的：\n\n      extension Collection where Element : Equatable {\n  /// 如果 `self` 包含一个等于\n  /// `sought` 的元素，则返回 `true`；否则返回 `false`。\n  func **contains**(_ sought: Element) -> Bool { ... }\n}\n      \n\n      然而，这些 index 方法有不同的语义，应该\n被命名为不同的名称：\n\n      extension Database {\n  /// 重建数据库的搜索索引\n  func **index**() { ... }\n\n  /// 返回给定表中的第 `n` 行。\n  func **index**(_ n: Int, inTable: TableID) -> TableRow { ... }\n}\n      \n\n      最后，避免”基于返回类型重载”，因为它在存在\n类型推断时会导致歧义。\n\n      extension Box {\n  /// 如果有的话，返回存储在 `self` 中的 `Int`，\n  /// 否则返回 `nil`。\n  func **value**() -> Int? { ... }\n\n  /// 如果有的话，返回存储在 `self` 中的 `String`，\n  /// 否则返回 `nil`。\n  func **value**() -> String? { ... }\n}\n      \n\n    \n  \n\n\n参数 \n             \n          \n\nfunc move(from **start**: Point, to **end**: Point)\n\n\n\n  \n    选择参数名称以服务于文档。即使参数名称不会出现在\n函数或方法的使用点，它们也扮演着重要的解释角色。\n\n\n    \n      选择这些名称使文档易于阅读。例如，\n这些名称使文档读起来很自然：\n\n      /// 返回包含 `self` 中满足 `**predicate**` 的元素的\n/// `Array`。\nfunc filter(_ **predicate**: (Element) -> Bool) -> [Generator.Element]\n\n/// 用 `**newElements**` 替换给定的 `**subRange**` 中的元素。\nmutating func replaceRange(_ **subRange**: Range<Index>, with **newElements**: [E])\n      \n\n      而这些则使文档变得笨拙和不合语法：\n\n      /// 返回包含 `self` 中满足 `**includedInResult**` 的元素的\n/// `Array`。\nfunc filter(_ **includedInResult**: (Element) -> Bool) -> [Generator.Element]\n\n/// 用 `**with**` 的内容替换 **`r` 指示的元素范围**。\nmutating func replaceRange(_ **r**: Range<Index>, **with**: [E])\n      \n\n    \n  \n  \n    当它简化常见用法时，利用默认参数。任何具有单个常用值的\n参数都是默认值的候选。\n\n\n    \n      默认参数通过隐藏不相关的信息来改进可读性。例如：\n\n      let order = lastName.compare(\n  royalFamilyName**, options: [], range: nil, locale: nil**)\n      \n\n      可以变成更简单的：\n\n      let order = lastName.**compare(royalFamilyName)**\n      \n\n      默认参数通常比使用方族更可取，因为它们对任何\n试图理解 API 的人来说都带来更低的认知负担。\n\n      extension String {\n  /// *...描述...*\n  public func compare(\n     _ other: String, options: CompareOptions **= []**,\n     range: Range<Index>? **= nil**, locale: Locale? **= nil**\n  ) -> Ordering\n}\n      \n\n      上面的可能不简单，但它比下面的要简单得多：\n\n      extension String {\n  /// *...描述 1...*\n  public func **compare**(_ other: String) -> Ordering\n  /// *...描述 2...*\n  public func **compare**(_ other: String, options: CompareOptions) -> Ordering\n  /// *...描述 3...*\n  public func **compare**(\n     _ other: String, options: CompareOptions, range: Range<Index>) -> Ordering\n  /// *...描述 4...*\n  public func **compare**(\n     _ other: String, options: StringCompareOptions,\n     range: Range<Index>, locale: Locale) -> Ordering\n}\n      \n\n      方法族的每个成员都需要单独记录\n并被用户理解。要在它们之间做出选择，用户需要\n理解所有这些，而且偶尔会出现令人惊讶的关系——例如，\nfoo(bar: nil) 和 foo() 并不总是同义词——这\n使得这成为一个寻找微小差异的繁琐过程，这些差异主要存在于\n几乎相同的文档中。使用带有默认值的单个方法提供了\n一个极大优越的程序员体验。\n    \n  \n  \n    优先将带有默认值的参数放在参数列表的末尾。没有默认值的\n参数通常对方法的语义更重要，并提供了一个稳定的\n初始使用模式。\n  \n  \n    如果你的 API 将在生产环境中运行，优先使用 #fileID 而不是替代方案。\n#fileID 节省空间并保护开发者的隐私。在永远不会被最终用户运行的 API 中\n（如测试助手和脚本）使用 #filePath，如果完整路径将简化开发工作流程或\n用于文件 I/O。使用 #file 以保持与 Swift 5.2 或更早版本的源代码兼容性。\n  \n\n\n参数标签 \n             \n          \n\nfunc move(from **start**: Point, to **end**: Point)\nx.move(**from:** x, **to:** y)\n\n\n\n  \n    当参数不能有效区分时省略所有标签，\n例如 min(number1, number2)、zip(sequence1, sequence2)。\n  \n  \n    在执行值保留类型转换的初始化器中，省略第一个参数标签，\n例如 Int64(someUInt32)\n\n\n    \n      第一个参数应该始终是转换的源。\n\n      extension String {\n  // 将 `x` 转换为给定基数的文本表示\n  init(**_** x: BigInt, radix: Int = 10)   <span class=\"commentary\">← 注意开头的下划线</span>\n}\n\ntext = \"The value is: \"\ntext += **String(veryLargeNumber)**\ntext += \" and in hexadecimal, it's\"\ntext += **String(veryLargeNumber, radix: 16)**\n      \n\n      然而，在”缩小”类型转换中，建议使用描述缩小的标签。\n\n      extension UInt32 {\n  /// 创建具有指定 `value` 的实例。\n  init(**_** value: Int16)            <span class=\"commentary\">← 扩展，所以没有标签</span>\n  /// 创建具有 `source` 最低 32 位的实例。\n  init(**truncating** source: UInt64)\n  /// 创建具有 `valueToApproximate` 最接近的\n  /// 可表示近似值的实例。\n  init(**saturating** valueToApproximate: UInt64)\n}\n      \n\n      \n        值保留类型转换是一个\n单态映射，即\n源值中的每个差异都会导致\n结果值中的差异。\n例如，从 Int8 到 Int64 的转换是值保留的，\n因为每个不同的 Int8 值都被转换为不同的 Int64 值。\n相反方向的转换，然而，不可能是值保留的：Int64 有更多可能的值\n超过了 Int8 能表示的范围。\n\n        注意：能否检索原始值与转换是否值保留无关。\n      \n\n    \n  \n  \n    当第一个参数构成介词短语的一部分��，\n给它一个参数标签。参数标签通常应该从介词开始，\n例如 x.removeBoxes(havingLength: 12)。\n\n\n    \n      当前两个参数代表单个抽象的部分时，会出现一个例外。\n\n      a.move(**toX:** b, **y:** c)\na.fade(**fromRed:** b, **green:** c, **blue:** d)\n      \n\n      在这种情况下，在介词之后开始参数标签，以保持抽象清晰。\n\n      a.moveTo(**x:** b, **y:** c)\na.fadeFrom(**red:** b, **green:** c, **blue:** d)\n      \n    \n  \n  \n    否则，如果第一个参数构成语法短语的一部分，则省略其标签，\n将任何前置词附加到基本名称上，例如 x.addSubview(y)\n\n\n    \n      这条准则意味着如果第一个参数不构成语法短语的一部分，它应该有一个标签。\n\n      view.dismiss(**animated:** false)\nlet text = words.split(**maxSplits:** 12)\nlet studentsByName = students.sorted(**isOrderedBefore:** Student.namePrecedes)\n      \n\n      注意，重要的是短语要传达正确的含义。\n以下内容在语法上是正确的，但会表达错误的意思。\n\n      view.dismiss(false)   <span class=\"commentary\">不要取消？取消一个布尔值？</span>\nwords.split(12)       <span class=\"commentary\">分割数字 12？</span>\n      \n\n      还要注意，具有默认值的参数可以被省略，\n在这种情况下不构成语法短语的一部分，所以它们\n应该始终有标签。\n    \n  \n  \n    标记所有其他参数。\n  \n\n\n特殊说明 \n             \n          \n\n\n  \n    标记元组成员并命名闭包参数，当它们出现在你的 API 中时。\n\n\n    \n      这些名称具有\n解释性作用，可以在文档注释中引用，\n并提供对元组成员的表达性访问。\n\n      /// 确保我们至少为 `requestedCapacity` 个元素\n/// 持有唯一引用的存储。\n///\n/// 如果需要更多存储，调用 `allocate` 时\n/// **`byteCount`** 等于要分配的最大对齐\n/// 字节数。\n///\n/// - Returns:\n///   - **reallocated**: 如果分配了新的内存块则为 `true`；\n///     否则为 `false`。\n///   - **capacityChanged**: 如果更新了 `capacity` 则为 `true`；\n///     否则为 `false`。\nmutating func ensureUniqueStorage(\n  minimumCapacity requestedCapacity: Int,\n  allocate: (_ **byteCount**: Int) -> UnsafePointer&lt;Void&gt;\n) -> (**reallocated:** Bool, **capacityChanged:** Bool)\n      \n\n      闭包参数的名称应该像顶层函数的参数名称一样选择。\n不支持在调用点出现的闭包参数的标签。\n    \n  \n  \n    对无约束多态性要特别小心（例如 Any、\nAnyObject 和无约束的泛型参数），以避免\n重载集中的歧义。\n\n\n    \n      例如，考虑这个重载集：\n\n      struct Array<Element> {\n  /// 在 `self.endIndex` 处插入 `newElement`。\n  public mutating func append(_ newElement: Element)\n\n  /// 按顺序在 `self.endIndex` 处插入 `newElements` 的内容。\n  public mutating func append<S: SequenceType>(_ newElements: S)\n    where S.Generator.Element == Element\n}\n      \n\n      这些方法形成一个语义族，参数类型\n乍看起来是截然不同的。然而，当 Element\n是 Any 时，单个元素可能与元素序列具有相同的类型。\n\n      var values: [Any] = [1, \"a\"]\nvalues.append([2, 3, 4]) // [1, \"a\", [2, 3, 4]] 还是 [1, \"a\", 2, 3, 4]？\n      \n\n      要消除歧义，更明确地命名第二个重载。\n\n      struct Array {\n  /// 在 `self.endIndex` 处插入 `newElement`。\n  public mutating func append(_ newElement: Element)\n\n  /// 按顺序在 `self.endIndex` 处插入 `newElements` 的内容。\n  public mutating func append<S: SequenceType>(**contentsOf** newElements: S)\n    where S.Generator.Element == Element\n}\n      \n\n      注意新名称如何更好地匹配文档注释。\n在这种情况下，编写文档注释实际上\n引起了 API 作者对这个问题的注意。\n    \n  \n\n\n\nvar elements = document.querySelectorAll(\"pre code\");\nfor (i in elements) {\n    var element = elements[i];\n    if (element.textContent) {\n        element.innerHTML = element.textContent\n            .replace(/\\*\\*([^\\*]+)\\*\\*/g, \"<strong>$1</strong>\")\n            .replace(/\\*([^\\*]+)\\*/g, \"<em>$1</em>\");\n    }\n}\nfunction show_or_hide_all(){\n    var checkboxes = document.getElementsByClassName('detail');\n    var button = document.getElementById('toggle');\n\n    if(button.value == '立即展开所有详细信息'){\n        for (var i in checkboxes){\n            checkboxes[i].checked = 'FALSE';\n        }\n        button.value = '立即折叠所有详细信息'\n    }else{\n        for (var i in checkboxes){\n            checkboxes[i].checked = '';\n        }\n        button.value = '立即展开所有详细信息';\n    }\n}\nif (location.search.match(/[?&]expand=true\\b/)) {\n    show_or_hide_all();\n}\n\n\n\n\n  \n",
    "url": "https://www.swift.org.gg/documentation/api-design-guidelines/",
    "related_links": [
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/SymbolDocumentation.html#//apple_ref/doc/uid/TP40016497-CH51-SW1",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/SymbolDocumentation.html#//apple_ref/doc/uid/TP40016497-CH51-SW13",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Attention.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Author.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Authors.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Bug.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Complexity.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Copyright.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Date.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Experiment.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Important.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Invariant.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Note.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Parameter.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Parameters.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Postcondition.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Precondition.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Remark.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Requires.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Returns.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/SeeAlso.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Since.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Throws.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Todo.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Version.html",
      "https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Warning.html"
    ]
  }
]